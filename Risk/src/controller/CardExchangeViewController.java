package controller;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Observable;
import java.util.Observer;
import java.util.Queue;

import domain.Card;
import domain.CardExchangeViewModel;
import domain.Player;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import service.GameService;

public class CardExchangeViewController implements Observer {

	/**
	 * Variable for reference for Label in CardExchange.fxml.
	 */
	@FXML
	private Label playerNameForCardExchange;

	/**
	 * Variable for reference for Label in CardExchange.fxml.
	 */
	@FXML
	private Label totalNumberOfCards;

	/**
	 * Variable for reference for Label in CardExchange.fxml.
	 */
	@FXML
	private Label cardTypeOne;

	/**
	 * Variable for reference for Label in CardExchange.fxml.
	 */
	@FXML
	private Label cardTypeTwo;

	/**
	 * Variable for reference for Label in CardExchange.fxml.
	 */
	@FXML
	private Label cardTypeThree;

	/**
	 * Variable for reference for Button in CardExchange.fxml.
	 */
	@FXML
	private Button handIn;

	/**
	 * Variable for reference for TextField in CardExchange.fxml.
	 */
	@FXML
	private TextField typeOneInput;

	/**
	 * Variable for reference for TextField in CardExchange.fxml.
	 */
	@FXML
	private TextField typeTwoInput;

	/**
	 * Variable for reference for TextField in CardExchange.fxml.
	 */
	@FXML
	private TextField typeThreeInput;

	/**
	 * Variable for reference for GridPane in CardExchange.fxml.
	 */
	@FXML
	private GridPane exchangeViewPane;

	/**
	 * Variable holds the value of current player.
	 */
	private Player currentPlayer;

	/**
	 * Variable holds the value of CardExchangeViewModel.
	 */
	private CardExchangeViewModel model;

	/**
	 * Variable holds the value of number of card of card type 1 entered by the user
	 * for exchanging.
	 */
	private Integer cardType1Input = 0;

	/**
	 * Variable holds the value of number of card of card type 2 entered by the user
	 * for exchanging.
	 */

	private Integer cardType2Input = 0;

	/**
	 * Variable holds the value of number of card of card type 2 entered by the user
	 * for exchanging.
	 */

	private Integer cardType3Input = 0;

	/**
	 * Variable is true in case the card exchanged by the player is of the territory
	 * owned by the player itself.
	 */
	Boolean ifPlayerHasCardTerritory = false;

	/**
	 * This methods updated the ui when called by the Subject
	 */
	@Override
	public void update(Observable o, Object arg) {

		model = (CardExchangeViewModel) o;
		currentPlayer = model.getCurrentPlayer();
		Queue<Card> playerCards = new LinkedList<>(model.getCurrentPlayerCards(currentPlayer));
		int totalCards = playerCards.size();

		int cardType1 = 0;
		int cardType2 = 0;
		int cardType3 = 0;

		while (!playerCards.isEmpty()) {
			if (playerCards.peek().getCardType().equalsIgnoreCase(GameService.INFANTRY_ARMY)) {
				cardType1++;
			} else if (playerCards.peek().getCardType().equalsIgnoreCase(GameService.CAVALRY_ARMY)) {
				cardType2++;
			} else {
				cardType3++;
			}
			playerCards.remove();
		}

		playerNameForCardExchange.setText(currentPlayer.getName());
		totalNumberOfCards.setText(String.valueOf(totalCards));
		cardTypeOne.setText(String.valueOf(cardType1));
		cardTypeTwo.setText(String.valueOf(cardType2));
		cardTypeThree.setText(String.valueOf(cardType3));
		typeOneInput.setText("");
		typeTwoInput.setText("");
		typeThreeInput.setText("");

	}

	/**
	 * This method handle {@link CardExchangeViewController#handIn} button event. It
	 * exchanges the number of cards entered by player.
	 * 
	 * @param event:
	 *            ActionEvent instance which is generated by user.
	 */
	public void exchangeCards(ActionEvent event) {
		int maxCard1 = Integer.parseInt(cardTypeOne.getText());
		int maxCard2 = Integer.parseInt(cardTypeTwo.getText());
		int maxCard3 = Integer.parseInt(cardTypeThree.getText());

		if (validateIfExchangePossible(maxCard1, maxCard2, maxCard3)) {
			if (validateInputText(maxCard1, maxCard2, maxCard3)) {
				removeCardsFromPlayer();
				model.setTotalNumberOfExchanges(model.getTotalNumberOfExchanges() + 1);
				if (ifPlayerHasCardTerritory) {
					model.setPlayerArmyCount(currentPlayer, 2);
				} else {
					model.setPlayerArmyCount(currentPlayer, 0);
				}
				String info = "Cards Exchanged";
				showInformation(info);
				model.setViewForCurrentPlayer(currentPlayer);
			} else {
				String error = "Enter Valid Input";
				showError(error);
			}
		} else {
			String error = "Not Enough Cards For Exchange";
			showError(error);
		}

	}

	/**
	 * This method removes the card exchanged by the player and add the removed
	 * cards to the initial deck of cards
	 */
	private void removeCardsFromPlayer() {

		Queue<Card> removedCards = new LinkedList<>();
		Iterator<Card> ite = model.getCurrentPlayerCards(currentPlayer).iterator();

		while (ite.hasNext()) {
			Card card = ite.next();
			if (cardType1Input > 0) {
				if (card.getCardType().equalsIgnoreCase(GameService.INFANTRY_ARMY)) {
					if (currentPlayer.getTerritories().contains(card.getCardTerritory())) {
						ifPlayerHasCardTerritory = true;
					}
					cardType1Input--;
					removedCards.add(card);
					ite.remove();
				}

			}
			if (cardType2Input > 0) {
				if (card.getCardType().equalsIgnoreCase(GameService.CAVALRY_ARMY)) {
					if (currentPlayer.getTerritories().contains(card.getCardTerritory())) {
						ifPlayerHasCardTerritory = true;
					}
					cardType2Input--;
					removedCards.add(card);
					ite.remove();
				}

			}
			if (cardType3Input > 0) {
				if (card.getCardType().equalsIgnoreCase(GameService.ARTILLERY_ARMY)) {
					if (currentPlayer.getTerritories().contains(card.getCardTerritory())) {
						ifPlayerHasCardTerritory = true;
					}
					cardType3Input--;
					removedCards.add(card);
					ite.remove();
				}
			}

		}
		model.getAllCards().addAll(removedCards);

	}

	/**
	 * This method validates the input entered by the user for exchanging the cards
	 * 
	 * @param maxCard1
	 *            : indicates the max number of cards of Type 1 player has.
	 * 
	 * @param maxCard2
	 *            : indicates the max number of cards of Type 2 player has.
	 * @param maxCard3
	 *            : indicates the max number of cards of Type 3 player has.
	 * @return : true if the user has input valid combination of cards for the
	 *         exchange else returns false.
	 */
	private boolean validateInputText(int maxCard1, int maxCard2, int maxCard3) {

		String cardType1Str = typeOneInput.getText();
		String cardType2Str = typeTwoInput.getText();
		String cardType3Str = typeThreeInput.getText();

		if (cardType1Str.isEmpty() && cardType2Str.isEmpty() && cardType3Str.isEmpty()) {
			return false;
		}
		if (!cardType1Str.isEmpty()) {
			cardType1Input = Integer.parseInt(cardType1Str);
		}
		if (!cardType2Str.isEmpty()) {
			cardType2Input = Integer.parseInt(cardType2Str);
		}
		if (!cardType3Str.isEmpty()) {
			cardType3Input = Integer.parseInt(cardType3Str);
		}
		if (cardType1Input < 0 || cardType2Input < 0 || cardType3Input < 0) {
			return false;
		} else if (cardType1Input > maxCard1 || cardType2Input > maxCard2 || cardType3Input > maxCard3) {
			return false;
		} else if ((cardType1Input + cardType2Input + cardType3Input) > (maxCard1 + maxCard2 + maxCard3)) {
			return false;
		} else if (cardType1Input + cardType2Input + cardType3Input == 3) {

			if (cardType1Input == 3 || cardType2Input == 3 || cardType3Input == 3) {
				return true;
			} else if (cardType1Input == 1 && cardType2Input == 1 && cardType3Input == 1) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}

	}

	/**
	 * This method checks if the user can exchange the cards or not.
	 * 
	 * @param cardType1
	 *            : indicates the max number of cards of Type 1 player has.
	 * @param cardType2
	 *            : indicates the max number of cards of Type 2 player has.
	 * @param cardType3
	 *            : indicates the max number of cards of Type 3 player has.
	 * @return : true if the user can exchange else returns false.
	 */
	private boolean validateIfExchangePossible(int cardType1, int cardType2, int cardType3) {
		if (cardType1 >= 3 || cardType2 >= 3 || cardType3 >= 3) {
			return true;
		} else if (cardType1 + cardType2 + cardType3 >= 3) {
			return true;
		} else {
			return false;
		}

	}

	/**
	 * This method is used to show am alert to user informing about various
	 * validation errors.
	 * 
	 * @param error:
	 *            Error to show to user.
	 */
	private void showError(String error) {
		Alert alert = new Alert(AlertType.ERROR);
		alert.setTitle("Error");
		alert.setHeaderText(null);
		alert.setContentText(error);
		alert.showAndWait();
	}

	/**
	 * This method is used to show information to user about various events.
	 * 
	 * @param state:
	 *            state to show to user.
	 */
	private void showInformation(String state) {

		Alert alert = new Alert(AlertType.INFORMATION);
		alert.setTitle("Game Information");
		alert.setHeaderText(null);
		alert.setContentText(state);
		alert.showAndWait();
	}

}
